{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["defer","resolve","reject","promise","success","failure","Error","listenDevicesDebounce","listenDevicesPollingSkip","listenDevicesDebug","TransportNodeHid","device","ledgerTransport","timeout","exchangeStack","apdu","ledgerWrap","channel","command","packetSize","sequenceIdx","offset","tmp","Buffer","alloc","writeUInt16BE","length","blockSize","result","concat","slice","ledgerUnwrap","data","responseLength","response","deferred","exchangeTimeout","transport","setTimeout","push","processNextExchange","send","debug","content","toString","i","write","recv","read","err","res","buffer","from","performExchange","offsetSent","firstReceived","toReceive","received","sendPart","receivePart","block","paddingSize","padding","fill","then","resultBin","size","clearTimeout","shift","close","path","HID","isSupported","list","map","d","setListenDevicesDebounce","delay","setListenDevicesPollingSkip","conditionToSkip","setListenDevicesDebug","log","listen","observer","unsubscribed","devices","descriptor","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener"],"mappings":"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","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport, { TransportError } from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport getDevices from \"./getDevices\";\nimport listenDevices from \"./listenDevices\";\n\n// FIXME drop\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: T => void,\n  reject: any => void\n};\nfunction defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function(success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw new Error(\"defer() error\"); // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\nlet listenDevicesDebounce = 500;\nlet listenDevicesPollingSkip = () => false;\nlet listenDevicesDebug = () => {};\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-u2f\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends Transport<string> {\n  device: HID.HID;\n  ledgerTransport: boolean;\n  timeout: number;\n  exchangeStack: Array<*>;\n\n  constructor(\n    device: HID.HID,\n    ledgerTransport: boolean = true, // FIXME not used?\n    timeout: number = 0 // FIXME not used?\n  ) {\n    super();\n    this.device = device;\n    this.ledgerTransport = ledgerTransport;\n    this.timeout = timeout;\n    this.exchangeStack = [];\n  }\n\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  static list = (): Promise<string[]> =>\n    Promise.resolve(getDevices().map(d => d.path));\n\n  static setListenDevicesDebounce = (delay: number) => {\n    listenDevicesDebounce = delay;\n  };\n\n  static setListenDevicesPollingSkip = (conditionToSkip: () => boolean) => {\n    listenDevicesPollingSkip = conditionToSkip;\n  };\n\n  static setListenDevicesDebug = (debug: boolean | ((log: string) => void)) => {\n    listenDevicesDebug =\n      typeof debug === \"function\"\n        ? debug\n        : debug\n          ? (...log) => console.log(\"[listenDevices]\", ...log)\n          : () => {};\n  };\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then(devices => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          observer.next({ type: \"add\", descriptor, device });\n        }\n      }\n    });\n    const { events, stop } = listenDevices(\n      listenDevicesDebounce,\n      listenDevicesPollingSkip,\n      listenDevicesDebug\n    );\n\n    const onAdd = device => {\n      if (unsubscribed || !device) return;\n      observer.next({ type: \"add\", descriptor: device.path, device });\n    };\n    const onRemove = device => {\n      if (unsubscribed || !device) return;\n      observer.next({ type: \"remove\", descriptor: device.path, device });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   */\n  static async open(path: string) {\n    return Promise.resolve(new TransportNodeHid(new HID.HID(path)));\n  }\n\n  exchange(apdu: Buffer): Promise<Buffer> {\n    function ledgerWrap(channel, command, packetSize) {\n      let sequenceIdx = 0;\n      let offset = 0;\n\n      let tmp = Buffer.alloc(7);\n      tmp.writeUInt16BE(channel, 0);\n      tmp[2] = 0x05; // TAG_APDU\n      tmp.writeUInt16BE(sequenceIdx, 3);\n      sequenceIdx++;\n      tmp.writeUInt16BE(command.length, 5);\n      let blockSize =\n        command.length > packetSize - 7 ? packetSize - 7 : command.length;\n      let result = Buffer.concat(\n        [tmp, command.slice(offset, offset + blockSize)],\n        blockSize + 7\n      );\n      offset += blockSize;\n      while (offset !== command.length) {\n        tmp = Buffer.alloc(5);\n        tmp.writeUInt16BE(channel, 0);\n        tmp[2] = 0x05; // TAG_APDU\n        tmp.writeUInt16BE(sequenceIdx, 3);\n        sequenceIdx++;\n        blockSize =\n          command.length - offset > packetSize - 5\n            ? packetSize - 5\n            : command.length - offset;\n        result = Buffer.concat(\n          [result, tmp, command.slice(offset, offset + blockSize)],\n          result.length + blockSize + 5\n        );\n        offset += blockSize;\n      }\n      return result;\n    }\n\n    function ledgerUnwrap(channel, data, packetSize) {\n      let offset = 0;\n      let responseLength;\n      let sequenceIdx = 0;\n      let response;\n      if (typeof data === \"undefined\" || data.length < 7 + 5) {\n        return;\n      }\n      if (data[offset++] !== channel >> 8) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (data[offset++] !== (channel & 0xff)) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (data[offset++] !== 0x05) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (data[offset++] !== 0x00) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      if (data[offset++] !== 0x00) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      responseLength = (data[offset++] & 0xff) << 8;\n      responseLength |= data[offset++] & 0xff;\n      if (data.length < 7 + responseLength) {\n        return;\n      }\n      let blockSize =\n        responseLength > packetSize - 7 ? packetSize - 7 : responseLength;\n      response = data.slice(offset, offset + blockSize);\n      offset += blockSize;\n      while (response.length !== responseLength) {\n        sequenceIdx++;\n        if (offset === data.length) {\n          return;\n        }\n        if (data[offset++] !== channel >> 8) {\n          throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n        }\n        if (data[offset++] !== (channel & 0xff)) {\n          throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n        }\n        if (data[offset++] !== 0x05) {\n          throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n        }\n        if (data[offset++] !== sequenceIdx >> 8) {\n          throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n        }\n        if (data[offset++] !== (sequenceIdx & 0xff)) {\n          throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n        }\n        blockSize =\n          responseLength - response.length > packetSize - 5\n            ? packetSize - 5\n            : responseLength - response.length;\n        if (blockSize > data.length - offset) {\n          return;\n        }\n        response = Buffer.concat(\n          [response, data.slice(offset, offset + blockSize)],\n          response.length + blockSize\n        );\n        offset += blockSize;\n      }\n      return response;\n    }\n\n    const deferred = defer();\n    let exchangeTimeout;\n    let transport;\n    if (!this.ledgerTransport) {\n      transport = apdu;\n    } else {\n      transport = ledgerWrap(0x0101, apdu, 64);\n    }\n\n    if (this.timeout !== 0) {\n      exchangeTimeout = setTimeout(() => {\n        // Node.js supports timeouts\n        deferred.reject(new TransportError(\"timeout\", \"timeout\"));\n      }, this.timeout);\n    }\n\n    // enter the exchange wait list\n    this.exchangeStack.push(deferred);\n\n    if (this.exchangeStack.length === 1) {\n      const processNextExchange = () => {\n        // don't pop it now, to avoid multiple at once\n        const deferred = this.exchangeStack[0];\n\n        const send = content => {\n          const { debug } = this;\n          if (debug) {\n            debug(\"=>\" + content.toString(\"hex\"));\n          }\n          const data = [0x00];\n          for (let i = 0; i < content.length; i++) {\n            data.push(content[i]);\n          }\n          this.device.write(data);\n          return Promise.resolve(content.length);\n        };\n\n        const recv = () =>\n          new Promise((resolve, reject) =>\n            this.device.read((err, res) => {\n              if (err || !res) reject(err);\n              else {\n                const buffer = Buffer.from(res);\n                const { debug } = this;\n                if (debug) {\n                  debug(\"<=\" + buffer.toString(\"hex\"));\n                }\n                resolve(buffer);\n              }\n            })\n          );\n\n        const performExchange = () => {\n          let offsetSent = 0;\n          let firstReceived = true;\n          let toReceive = 0;\n\n          let received = Buffer.alloc(0);\n          const sendPart = () => {\n            if (offsetSent === transport.length) {\n              return receivePart();\n            }\n            const blockSize =\n              transport.length - offsetSent > 64\n                ? 64\n                : transport.length - offsetSent;\n            let block = transport.slice(offsetSent, offsetSent + blockSize);\n            const paddingSize = 64 - block.length;\n            if (paddingSize !== 0) {\n              let padding = Buffer.alloc(paddingSize).fill(0);\n              block = Buffer.concat(\n                [block, padding],\n                block.length + paddingSize\n              );\n            }\n            return send(block).then(() => {\n              offsetSent += blockSize;\n              return sendPart();\n            });\n          };\n\n          const receivePart = () => {\n            if (!this.ledgerTransport) {\n              return recv().then(result => {\n                received = Buffer.concat(\n                  [received, result],\n                  received.length + result.length\n                );\n                if (firstReceived) {\n                  firstReceived = false;\n                  if (received.length === 2 || received[0] !== 0x61) {\n                    return received;\n                  } else {\n                    toReceive = received[1];\n                    if (toReceive === 0) {\n                      toReceive = 256;\n                    }\n                    toReceive += 2;\n                  }\n                }\n                if (toReceive < 64) {\n                  return received;\n                } else {\n                  toReceive -= 64;\n                  return receivePart();\n                }\n              });\n            } else {\n              return recv().then(result => {\n                received = Buffer.concat(\n                  [received, result],\n                  received.length + result.length\n                );\n                const response = ledgerUnwrap(0x0101, received, 64);\n                if (typeof response !== \"undefined\") {\n                  return response;\n                } else {\n                  return receivePart();\n                }\n              });\n            }\n          };\n          return sendPart();\n        };\n\n        performExchange()\n          .then(result => {\n            let response,\n              resultBin = result;\n            if (!this.ledgerTransport) {\n              if (resultBin.length === 2 || resultBin[0] !== 0x61) {\n                response = resultBin;\n              } else {\n                let size = resultBin[1];\n                // fake T0\n                if (size === 0) {\n                  size = 256;\n                }\n                response = resultBin.slice(2);\n              }\n            } else {\n              response = resultBin;\n            }\n            // build the response\n            if (this.timeout !== 0) {\n              clearTimeout(exchangeTimeout);\n            }\n            return response;\n          })\n          .then(\n            response => {\n              // consume current promise\n              this.exchangeStack.shift();\n\n              // schedule next exchange\n              if (this.exchangeStack.length > 0) {\n                processNextExchange();\n              }\n              return response;\n            },\n            (err: Error) => {\n              if (this.timeout !== 0) {\n                clearTimeout(exchangeTimeout);\n              }\n              throw err;\n            }\n          )\n          // plug to deferred\n          .then(deferred.resolve, deferred.reject);\n      };\n\n      // schedule next exchange\n      processNextExchange();\n    }\n\n    // the exchangeStack will process the promise when possible\n    return deferred.promise;\n  }\n\n  setScrambleKey() {}\n\n  close(): Promise<void> {\n    this.device.close();\n    return Promise.resolve();\n  }\n}\n"]}